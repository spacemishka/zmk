/*
 * Copyright (c) 2020 The ZMK Contributors
 *
 * SPDX-License-Identifier: MIT
 */

//#include <behaviors.dtsi>
//#include <dt-bindings/zmk/keys.h>
//#include <dt-bindings/zmk/bt.h>
//#include <dt-bindings/zmk/ext_power.h>

#include <behaviors.dtsi>

#include <dt-bindings/zmk/keys.h>

#include <dt-bindings/zmk/bt.h>

#include <dt-bindings/zmk/rgb.h>

#include <dt-bindings/zmk/ext_power.h>

er Profiler
GitHub


Getting Started
Features
Keymaps
Combos
Conditional Layers
Debouncing
Displays
Encoders
RGB Underglow
Backlight
Battery Level
Beta Testing
Behaviors
Codes
Configuration
Development
RGB Underglow
RGB underglow is a feature used to control "strips" of RGB LEDs. Most of the time this is called underglow and creates a glow underneath the board using a ring of LEDs around the edge, hence the name. However, this can be extended to be used to control anything from a single LED to a long string of LEDs anywhere on the keyboard.

INFO
RGB underglow can also be used for under-key lighting. If you have RGB LEDs on your keyboard, this is what you want. For PWM/single color LEDs, see Backlight.

ZMK supports all the RGB LEDs supported by Zephyr. Here's the current list supported:

WS2812-ish (WS2812B, WS2813, SK6812, or compatible)
APA102
LPD880x (LPD8803, LPD8806, or compatible)
Of the compatible types, the WS2812 LED family is by far the most popular type. Currently each of these types of LEDs are expected to be run using SPI with a couple of exceptions.

Here you can see the RGB underglow feature in action using WS2812 LEDs.


Enabling RGB Underglow
To enable RGB underglow on your board or shield, simply enable the CONFIG_ZMK_RGB_UNDERGLOW and CONFIG_*_STRIP configuration values in the .conf file for your board or shield. For example:

CONFIG_ZMK_RGB_UNDERGLOW=y
# Use the STRIP config specific to the LEDs you're using
CONFIG_WS2812_STRIP=y

See Configuration Overview for more instructions on how to use Kconfig.

If your board or shield does not have RGB underglow configured, refer to Adding RGB Underglow to a Board.

Configuring RGB Underglow
See RGB underglow configuration.

Adding RGB Underglow to a Board
RGB underglow is always added to a board, not a shield. This is a consequence of needing to configure SPI to control the LEDs. If you have a shield with RGB underglow, you must add a boards/ directory within your shield folder to define the RGB underglow individually for each board that supports the shield. Inside the boards/ folder, you define a <board>.overlay for each different board. For example, the Kyria shield has a boards/nice_nano.overlay file that defines the RGB underglow for the nice_nano board specifically.

nRF52-based boards
With nRF52 boards, you can just use &spi1 and define the pins you want to use.

To identify which pin number you need to put in the config you need do to a bit of math. You need the hardware port and run it through a function. 32 * X + Y = <Pin number> where X is first part of the hardware port "PX.01" and Y is the second part of the hardware port "P1.Y".

(P1.13 would give you 32 * 1 + 13 = <45> and P0.15 would give you 32 * 0 + 15 = <15>)

Here's an example on a definition that uses P0.06:

#include <dt-bindings/led/led.h>

&spi1 {
  compatible = "nordic,nrf-spim";
  status = "okay";
  mosi-pin = <6>;
  // Unused pins, needed for SPI definition, but not used by the ws2812 driver itself.
  sck-pin = <5>;
  miso-pin = <7>;

  led_strip: ws2812@0 {
    compatible = "worldsemi,ws2812-spi";
    label = "WS2812";

    /* SPI */
    reg = <0>; /* ignored, but necessary for SPI bindings */
    spi-max-frequency = <4000000>;

    /* WS2812 */
    chain-length = <10>; /* number of LEDs */
    spi-one-frame = <0x70>;
    spi-zero-frame = <0x40>;
    color-mapping = <LED_COLOR_ID_GREEN
                          LED_COLOR_ID_RED
                          LED_COLOR_ID_BLUE>;
  };
};





/ {
	keymap {
		compatible = "zmk,keymap";

		default_layer {
// ------------------------------------------------------------------------------------------------------------
// |  ESC  |  1  |  2  |  3   |  4   |  5   |                   |  6   |  7    |  8    |  9   |   0   |   ß   |
// |  TAB  |  Q  |  W  |  E   |  R   |  T   |                   |  Y   |  U    |  I    |  O   |   P   |   Ü   |
// |  CTRL |  A  |  S  |  D   |  F   |  G   |                   |  H   |  J    |  K    |  L   |   Ö   |   Ä   |
// | SHIFT |  Z  |  X  |  C   |  V   |  B   |  _   |  |  "["  |  N   |  M    |  ,    |  .   |   /   | SHIFT |
//                     | ALT  | GUI  | LOWER|  SPACE |  | ENTER | RAISE| BSPC  | GUI   |
			bindings = <
&kp ESC   &kp N1 &kp N2 &kp N3   &kp N4   &kp N5                     &kp N6 &kp N7   &kp N8    &kp N9  &kp N0   &kp MINUS
&kp TAB   &kp Q  &kp W  &kp E    &kp R    &kp T                      &kp Y  &kp U    &kp I     &kp O   &kp P    &kp LBKT
&kp LCTRL &kp A  &kp S  &kp D    &kp F    &kp G                      &kp H  &kp J    &kp K     &kp L   &kp SEMI &kp SQT
&kp LSHFT &kp Z  &kp X  &kp C    &kp V    &kp B  &kp KP_MINUS   &kp RBKT &kp N  &kp M    &kp COMMA &kp DOT &kp FSLH &kp RSHFT
                        &kp LALT &kp LGUI &mo 1  &kp SPACE  &kp RET  &mo 2  &kp BSPC &kp RGUI
			>;

			sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN>;
		};

		lower_layer {
// ------------------------------------------------------------------------------------------------------------
// | BTCLR | BT1 | BT2 |  BT3 |  BT4 |  BT5 |                   |      |       |       |      |       |       |
// |  F1   |  F2 |  F3 |  F4  |  F5  |  F6  |                   |  F7  |  F8   |  F9   |  F10 |  F11  |  F12  |
// |   `   |  !  |  @  |  #   |  $   |  %   |                   |  ^   |  &    |  *    |  (   |   )   |   ~   |
// |       |     |     |      |      |      |        |  |       |      |  _    |  +    |  {   |   }   |  "|"  |
//                     |      |      |      |        |  |       |      |       |       |
			bindings = <
&bt BT_CLR &bt BT_SEL 0     &bt BT_SEL 1      &bt BT_SEL 2      &bt BT_SEL 3 &bt BT_SEL 4                 &bt BT_SEL 4    &trans    &trans          &trans    &trans    &trans
&kp F1     &kp F2           &kp F3            &kp F4            &kp F5       &kp F6                       &kp F7    &kp F8    &kp F9          &kp F10   &kp F11   &kp F12
&kp GRAVE  &kp EXCL         &kp AT            &kp HASH          &kp DOLLAR   &kp PRCNT                    &kp CARET &kp AMPS  &kp KP_MULTIPLY &kp LPAR  &kp RPAR  &kp TILDE
&trans     &trans           &trans            &trans           &trans       &trans    &trans   &trans    &trans    &kp MINUS &kp KP_PLUS     &kp LBRC  &kp RBRC  &kp PIPE
                                              &trans            &trans       &trans    &trans   &trans    &trans    &trans    &trans
			>;

			sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN>;
		};

		raise_layer {
// ------------------------------------------------------------------------------------------------------------
// |       |     |     |      |      |      |                   |      |       |       |      |       |       |
// |   `   |  1  |  2  |  3   |  4   |  5   |                   |  6   |   7   |   8   |  9   |   0   |       |
// |   F1  |  F2 |  F3 |  F4  |  F5  |  F6  |                   |      |   <-  |   v   |  ^   |  ->   |       |
// |   F7  |  F8 |  F9 |  F10 |  F11 |  F12 |        |  |       |  +   |   -   |   =   |  [   |   ]   |   \   |
//                     |      |      |      |        |  |       |      |       |       |
			bindings = <
&trans    &trans &trans &trans  &trans  &trans                       &trans      &trans    &trans    &trans   &trans    &trans
&kp GRAVE &kp N1 &kp N2 &kp N3  &kp N4  &kp N5                       &kp N6      &kp N7    &kp N8    &kp N9   &kp N0    &trans
&kp F1    &kp F2 &kp F3 &kp F4  &kp F5  &kp F6                       &trans      &kp LEFT  &kp DOWN  &kp UP   &kp RIGHT &trans
&kp F7    &kp F8 &kp F9 &kp F10 &kp F11 &kp F12   &trans   &trans    &kp KP_PLUS &kp MINUS &kp EQUAL &kp LBKT &kp RBKT  &kp BSLH
                        &trans  &trans  &trans    &trans   &trans    &trans      &trans    &trans
			>;

			sensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN>;
		};
	};
};
